--[[--------------------------------------------------------------------------
--
------------------------------ VoxelBuffer
--  by ProfBeetle
--
-- Buffers mass changes to and from Smooth Terrian so you
-- don't have to deal with Region3s.
--

With the VoxelBuffer you can set voxels anywhere without having to worry about Region bounds or 4x4 alignment. You can
set thousands of them (up to the limits of your computer) then commit them all at once to your Terrain in one call.

It works by internally dividing world space up into regions and tracking changes within those regions in
dynamically generated buffers.

NOTE: when a new buffered region is created, either by setting or getting a voxel, it is populated by reading
the voxels from the current Terrain

The VoxelBuffer has 3 main functions, setVoxel(x, y, z, material, occupancy), getVoxel(x, y, z) and commitToTerrian().

Simple example:

	local voxelBuffer = voxelBuffer.VoxelBuffer.new()

	voxelBuffer:setVoxel(100, 100, 100, Enum.Material.Ground, 1)
	voxelBuffer:setVoxel(10000, 10000, 10000, Enum.Material.Ground, 1)
	voxelBuffer:commitToTerrian()
	
NOTE: setVoxel() and getVoxel() take world space block locations but voxels are 4x4 blocks, 
so calling setVoxel(0, 0, 0, m, 1) and setVoxel(3, 3, 3, m, 1) sets
the exact same voxel twice.

--]]--------------------------------------------------------------------------

-- buffer size, you can set these to (almost) anything, I've optimized them for my use
-- the one limitation is that they can't be larger than the maximums for a Region3
-- NOTE: they must also be divisable by 4 or wierd things will happen at the edges
-- NOTE: they must also be divisible by 4 or weird things will happen at the edges
local bufferXMax = 256
local bufferYMax = 40
local bufferZMax = 256

local floor = math.floor

-- buffered internal region representation backed by an actual Region3
local VoxelRegion = {}
VoxelRegion.__index = VoxelRegion
function VoxelRegion.new(x, y, z, material, occupancy)
	local self = setmetatable({}, VoxelRegion)
	self.region = Region3.new(Vector3.new(x, y, z), Vector3.new(x + bufferXMax, y + bufferYMax, z + bufferZMax)):ExpandToGrid(4)
	self.material = nil
	self.occupancy = nil
	return self
end
function VoxelRegion:setVoxel(x, y, z, material, occupancy)
	local xr = floor(x/4)+1
	local yr = floor(y/4)+1
	local zr = floor(z/4)+1
	self.material[xr][yr][zr] = material
	self.occupancy[xr][yr][zr] = occupancy
end
function VoxelRegion:getVoxel(x, y, z)
	local xr = floor(x/4)+1
	local yr = floor(y/4)+1
	local zr = floor(z/4)+1
	local material = self.material[xr][yr][zr]
	local occupancy = self.occupancy[xr][yr][zr]
	return material, occupancy
end

-- the voxel buffer
local VoxelBuffer = {}
VoxelBuffer.__index = VoxelBuffer
function VoxelBuffer.new()
	local self = setmetatable({}, VoxelBuffer)
	self.regions = {}
	self.regionCount = 0
	return self
end
-- given a world space coordinate returns its buffer region location and offset within that region
function VoxelBuffer:getLocations(x, y, z)
	local regionLocation = Vector3.new(floor(x / bufferXMax), floor(y / bufferYMax), floor(z / bufferZMax))
	local voxelLocation = Vector3.new(x - regionLocation.x * bufferXMax, y - regionLocation.y * bufferYMax, z - regionLocation.z * bufferZMax)
	return regionLocation, voxelLocation
end
-- given a location generated by the function above, get a buffered region or create one if it doesn't already exist
-- NOTE: when a new buffered region is created, either by setting or getting a voxel, it is populated by reading
-- the region from the current Terrain
function VoxelBuffer:getOrMakeBufferedRegion(rLocation)
	local xR, yR, zR = rLocation.x, rLocation.y, rLocation.z
	-- get the region
	local key = tostring(xR) .. "-" .. tostring(yR) .. "-" .. tostring(zR)
	local region = self.regions[key]
	-- see if this region exist, if not make it
	if (region == nil) then		
		region = VoxelRegion.new(xR * bufferXMax, yR * bufferYMax, zR * bufferZMax)
		region.material, region.occupancy = workspace.Terrain:ReadVoxels(region.region, 4)
		self.regions[key] = region
		self.regionCount = self.regionCount + 1
	end
	return region	
end

-- set a voxel
-- NOTE: setVoxel() takes world space block locations but voxels are 4x4 blocks, 
-- so calling setVoxel(0, 0, 0, m, 1) and setVoxel(3, 3, 3, m, 1) is setting
-- the exact same voxel twice.
function VoxelBuffer:setVoxel(x, y, z, material, occupancy)
	local rLoc, vLoc = VoxelBuffer.getLocations(self, x, y, z)
	local region = VoxelBuffer.getOrMakeBufferedRegion(self, rLoc)
	region:setVoxel(vLoc.x, vLoc.y, vLoc.z, material, occupancy)
end
-- get a voxel
-- see the note on setVoxel()
function VoxelBuffer:getVoxel(x, y, z)
	local rLoc, vLoc = VoxelBuffer.getLocations(self, x, y, z)
	local region = VoxelBuffer.getOrMakeBufferedRegion(self, rLoc)
	region:getVoxel(vLoc.x, vLoc.y, vLoc.z)
end
-- write all the buffered voxels to the Terrain
function VoxelBuffer:commitToTerrian()
	print("VoxelBufer: Committing " .. self.regionCount .. " regions.")
	for key, region in pairs(self.regions) do
		workspace.Terrain:WriteVoxels(region.region, 4, region.material, region.occupancy)
		wait()
	end
end
-- clear all the buffered regions. This does not clear the Terrain.
function VoxelBuffer:clear()
	self.regions = {}
	self.regionCount = 0
end


local module = {}

module.VoxelBuffer = VoxelBuffer

return module
